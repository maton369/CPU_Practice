
/* 
// asm_sum.c
#include <stdio.h>

【このコードの目的】
- 1〜10 の総和（55）を、Cのfor文ではなく「アセンブリ命令列」で計算する。
- CPU（特に自作CPU）視点では、単なる加算よりも
  「比較 → 条件分岐 → ループ → PC更新」という制御系が正しく動くかを確認するための教材である。

【自作CPU観点でこのコードがテストしているもの】
1) mov reg, imm でレジスタに即値をロードできるか（即値生成・レジスタ書き込み）
2) cmp で比較し、フラグ（ZFなど）を正しく更新できるか（ALU/フラグ生成）
3) je でフラグに基づく条件分岐ができるか（条件分岐・PC更新）
4) add でレジスタ加算できるか（ALU・レジスタ書き戻し）
5) inc で 1 増加できるか（専用命令 or addi相当）
6) jmp で無条件ジャンプできるか（PC更新）
7) mov mem, reg でレジスタの結果をメモリへ書けるか（ストア）

【全体アルゴリズム（擬似コード）】
  ax = 0          // 累積和（accumulator）
  bx = 1          // ループカウンタ（i）
  while (true):
    if (bx == 11):   // 11になったら終了
        break
    ax = ax + bx     // 足し込み
    bx = bx + 1      // カウンタ更新
  sum = ax

- bxが 1..10 の間だけ ax に加算され、bx==11 になった瞬間に抜ける。
- 結果は ax = 55 となり、sum に保存される。

【注意：インラインアセンブラの方言】
- __asm { ... } は主に MSVC（Microsoft Visual C++）系のインラインアセンブラ構文である。
- GCC/Clang の asm とは互換ではない。
- さらに環境によっては 64bit でインラインアセンブラが制限されることがある。
- 使用している ax/bx は x86 の 16bit レジスタである（AX, BX）。

*/

#include <stdio.h>

void main(void) {
    /*
      short sum;
      - 16bit の変数として総和を受け取る。
      - ax も 16bit なので、結果幅の整合が取りやすい。
      - 自作CPUで幅（16bit/32bit）を意識して設計する段階では重要なポイント。
    */
    short sum; // 変数sumの定義（16bit）

    __asm {  // インラインアセンブラの開始（MSVC系）

        /*
          mov ax, 0
          - AX を 0 で初期化する。
          - AX を「累積和（accumulator）」として使う。

          自作CPU観点：
          - 即値 0 をレジスタへ入れる命令が必要。
          - 0 は専用のゼロレジスタ等で表現する設計もあり得るが、
            ここでは単純な即値ロードのテストになる。
        */
        mov ax, 0

        /*
          mov bx, 1
          - BX を 1 で初期化する。
          - BX を「ループカウンタ（i）」として使う。

          自作CPU観点：
          - ループは「カウンタ」「比較」「分岐」で構成されるので、
            BX は制御系の動作確認の中心となる。
        */
        mov bx, 1

        /*
          LOOP1:
          - ループ先頭のラベル。
          - jmp LOOP1 によってここへ戻り、反復を実現する。

          自作CPU観点：
          - アセンブラは LOOP1 を「命令アドレス」に解決する（ラベル解決）。
          - CPUはジャンプ先アドレスを PC に反映する（PC更新）。
          - どちらかがズレるとループは成立しない。
        */
    LOOP1:

        /*
          cmp bx, 11
          - BX と 11 を比較する。
          - x86の cmp は「BX - 11」を内部的に計算し、結果は捨ててフラグだけ更新する。

            代表的なフラグ：
            - ZF (Zero Flag) : (bx - 11 == 0) のとき 1 になる（等しい）
            - SF (Sign Flag) : 符号（減算結果の最上位ビット）
            - CF/OF など     : キャリー/オーバーフロー（設計により扱いが重要）

          自作CPU観点：
          - “比較命令”を独立で持つか、減算+分岐で代替するかはISA設計の重要事項。
          - フラグ方式（ZF等）を採用する場合、cmp/add/sub などがフラグをどう更新するかを仕様化する必要がある。
        */
        cmp bx, 11

        /*
          je MOUT
          - Jump if Equal（等しいときジャンプ）。
          - 直前の cmp により ZF が 1（等しい）なら MOUT へ飛ぶ。

          ここで実現している制御：
          - bx == 11 になったらループ終了
          - bx != 11 の間はループ本体を続ける

          自作CPUで壊れやすいポイント：
          - cmp が ZF を正しく更新していない
          - je が ZF の意味を逆に解釈している
          - 分岐先アドレス（MOUT）の計算/反映がズレている
          - PC更新のタイミングのミス（フェッチと実行の整合）
        */
        je  MOUT

        /*
          add ax, bx
          - AX = AX + BX を実行する（累積加算）。
          - ここが「総和」の本体。

          自作CPU観点：
          - レジスタ読み出し（AX, BX）
          - ALU加算
          - AXへの書き戻し
          - （フラグ方式なら）フラグ更新
        */
        add ax, bx

        /*
          inc bx
          - BX = BX + 1 を実行する（カウンタ更新）。

          ISA設計観点：
          - inc のような単機能命令を用意するか
          - add bx, 1 の即値加算で統一するか
          の設計選択がある。
          最小命令セットの自作CPUでは inc を省き、addi相当で代替することが多い。
        */
        inc bx

        /*
          jmp LOOP1
          - 無条件ジャンプでループ先頭に戻る。

          自作CPU観点：
          - 無条件ジャンプは PC を強制的に書き換える命令。
          - 条件分岐（je）と無条件分岐（jmp）の両方が揃うと、
            “終了条件で抜けるループ” を素直に表現できる。
        */
        jmp LOOP1

        /*
          MOUT:
          - ループ終了後の到達点（ラベル）。
          - je によってここへ飛んできた時点で bx == 11 が成立している。
        */
    MOUT:

        /*
          mov sum, ax
          - AX の計算結果（55）を、C変数 sum が置かれているメモリへ書き込む。

          自作CPU観点：
          - レジスタ → メモリ の store が正しいかを確認できる。
          - sum がローカル変数なので、実体はスタック上に配置されることが多い。
            その場合、コンパイラは sum のアドレスを [bp-オフセット] などで管理する。
          - 自作CPUでスタック/フレームポインタを実装する段階ではここが重要になる。

          ※インラインアセンブラでは「sum」という記号をコンパイラが適切に解決する前提で動いている。
        */
        mov sum, ax
    } // インラインアセンブラの終了

    /*
      printf("sum = %d\n", sum);

      自作CPU観点では注意：
      - printf は標準ライブラリ依存が極めて強い（OS/ランタイム/ABI/スタック/I/Oなどが必要）。
      - bring-up 初期は printf を外し、sum の値（55）を
        デバッガ/メモリダンプ/テストベンチで確認する方が段階的に進めやすい。
      - I/O は UART などの最小出力から整備し、最後に printf 相当へ進むのが現実的。
    */
    printf("sum = %d\n", sum); // sumの値を表示
}

/*
  【期待値】
  - sum = 55

  【このコードが自作CPUにとって良い理由】
  - ループの最小構成（比較→条件分岐→本体→更新→無条件ジャンプ）が明確に見える。
  - 不具合が出たときに、原因を
      - フラグ生成（cmp）
      - 条件分岐（je）
      - PC更新（jmp/je）
      - ALU（add/inc）
      - メモリ書き込み（mov sum, ax）
    のどこにあるか切り分けやすい。
*/
