#include <stdio.h>

/*
  【このプログラムの目的（自作CPU観点）】
  - 1〜10の総和（55）を、Cのfor文ではなく「命令列（アセンブリ）」で計算する。
  - 自作CPUを作る/理解する上では、次の要素が明示的に含まれる点が重要である。

    含まれる主要要素：
    1) レジスタ初期化（xor ax, ax / mov bx, 1）
    2) ALU加算（add）
    3) インクリメント（inc）
    4) 比較（cmp）→ フラグ更新（ZF等）
    5) 条件分岐（jne）によるループ
    6) レジスタ→メモリへの書き戻し（sumへ保存）

  - つまり「データパス（ALU/レジスタ）」と「制御（分岐/PC更新）」を同時にテストできる。
  - また、C変数 sum への書き戻しを含むため「レジスタ→メモリ（store）」も検証できる。
*/

/*
  【なぜ元のIntel記法版がビルドで落ちたのか（今回の修正方針）】
  - Intel記法（.intel_syntax noprefix）に切り替えた状態で、GCCの %0（"=m"(sum)）を使うと、
    %0 が AT&T 風のアドレス表現（例：-2(%rbp)）に展開されることがある。
  - Intel記法では `(%rbp)` のような表現がそのままでは解釈できず、
      Error: junk `(%rbp)' after expression
    となる。
  - したがって、ここでは「最初から最後まで AT&T 記法で統一」し、
    %0 の展開と確実に整合する形にしている。

  - AT&T 記法の特徴：
    * レジスタは %ax, %bx のように % を付ける（インラインasm内では %%ax のように書く）
    * 即値は $11 のように $ を付ける
    * オペランド順は「src, dst」
    * サイズは接尾辞で明示（16bitなら w：movw/addw/cmpw/incw）
*/

int main(void) {
    /*
      sum は 16bit の符号なし整数として扱う。
      - x86の AX レジスタは16bitなので、AX→sum への書き戻しが自然に一致する。
      - 自作CPUでは “演算のビット幅” と “メモリへ保存する幅” が一致しているかが重要で、
        幅がズレると上位ビットの扱いや符号拡張がバグ要因になる。
    */
    unsigned short sum;

    /*
      asm volatile(...) は GCC/Clang の「GNU拡張インラインアセンブリ」。

      - asm: ここに書いた文字列をアセンブリとして組み込む
      - volatile: このasmは副作用（sumを書き換える等）があるので、
        コンパイラに「消すな・勝手に順序を変えるな」と伝える

      自作CPU観点：
      - ここに書かれた命令列が、そのままCPUが実行する“制御フロー”の最小例になる。
      - ループの動作（PC更新、条件分岐、フラグ）が壊れているとすぐ症状が出るため、
        bring-up のテストとして非常に有効。
    */
    asm volatile(
        /*
          xorw %ax, %ax
          - 16bit（w）で AX を0クリアする。
          - XORで同じレジスタをXORすると結果は常に0になるため、
            即値0を埋め込まずにゼロ化できる（定番テクニック）。

          自作CPU観点：
          - XOR命令を持つかどうかで、ゼロクリアの実現方法が変わる。
          - XORを持たない最小ISAなら、li/addi などで0を生成することになる。
        */
        "xorw %%ax, %%ax\n"

        /*
          movw $1, %bx
          - 16bit（w）で BX = 1 をセットする。
          - BX をループカウンタとして使う。
        */
        "movw $1, %%bx\n"

        /*
          1: はローカルラベル（数字ラベル）。
          - 末尾の jne 1b の "b" は backward を意味し、
            「直前の 1: に戻れ」という指定になる。
          - アセンブラがこのラベルを正しいアドレスに解決できること、
            CPUがPCをそのアドレスに更新できることがループ成立の条件。
        */
        "1:\n"

        /*
          addw %bx, %ax
          - 16bit（w）で AX = AX + BX を行う。
          - 総和の累積に相当し、BXが1..10を取るため、最終的にAX=55になる。

          自作CPU観点：
          - ALU加算器
          - レジスタ読み出し（AX,BX）
          - 書き戻し（AX）
          のデータパスが正しいかを検証できる。
        */
        "addw %%bx, %%ax\n"

        /*
          incw %bx
          - 16bit（w）で BX = BX + 1 を行う。
          - ループカウンタを更新する。

          自作CPU観点：
          - inc のような専用命令を持つか、
            addi（add immediate）で代替するかはISA設計の判断点。
        */
        "incw %%bx\n"

        /*
          cmpw $11, %bx
          - 16bit（w）で BX と 11 を比較してフラグ（ZF等）を更新する。
          - x86の cmp は概念的には「BX - 11」を計算し、
            結果を捨ててフラグだけ残す。

          自作CPU観点：
          - フラグレジスタ（ZFなど）を持つ設計かどうか
          - 比較命令を独立で持つか、sub結果で分岐するか
            といった制御系の設計に直結する。
        */
        "cmpw $11, %%bx\n"

        /*
          jne 1b
          - 直前の cmp の結果が「等しくない」なら（ZF=0）ラベル1に戻る。
          - BX が 11 になるまで繰り返す。

          ループ回数の確認：
          - 初期 BX=1
          - ループ内で add → inc の順
            * add は BX=1..10 の10回実行される
            * BX が 11 になった時点で cmp が等しい→jneしない→脱出
        */
        "jne 1b\n"

        /*
          movw %ax, %0
          - 16bit（w）で AX の値を「出力オペランド %0」に書き込む。
          - %0 は下の : "=m"(sum) に対応し、sum のメモリ位置を指す。
          - AT&T 記法ではオペランド順は src, dst なので、
            「AX → sum」になるよう movw %%ax, %0 と書く。

          自作CPU観点：
          - “レジスタで計算した結果をメモリへ保存する（store）” の典型。
          - load/store型の自作CPUなら store 命令の動作確認に相当する。
        */
        "movw %%ax, %0\n"

        /*
          オペランド指定（GCC拡張インラインasmの重要部分）

          : "=m"(sum)
            - 出力（Output operands）
            - "=m" は「メモリに書く出力」を意味する。
            - これにより、コンパイラは「このasmがsumを書き換える」ことを理解し、
              最適化で消したり、順序を誤ったりしにくくなる。

          : （入力なし）
            - 入力オペランドが無い（このasmは内部で完結）。

          : "ax", "bx", "cc"
            - clobber（破壊するものの宣言）
            - asm内でAX/BXを変更するため、コンパイラにその事実を伝える。
            - "cc" は condition codes（フラグ）が変化することを宣言する。
              cmp/jne を使うので、これを入れるのが安全。
        */
        : "=m"(sum)           // 出力：sum（メモリ）に書き込む
        :                     // 入力：なし
        : "ax", "bx", "cc"    // 破壊：AX/BX と フラグ
    );

    /*
      printf は標準ライブラリ依存（OS/ランタイム/I/O）を伴う。
      - 自作CPU bring-up では printf を動かす前に、
        sum が 55 になっていることをメモリ/レジスタ観測で確認するのが定石。

      表示フォーマット：
      - sum は unsigned short だが、可変長引数では整数昇格で int 扱いになるため、
        "%u" で表示しても一般に問題は起きにくい。
    */
    printf("sum = %u\n", sum);

    /*
      Linux上では return 0 が自然な終了。
      ベアメタル環境（自作CPU単体）では return 先が無いことが多いので
      while(1)で止める設計もよくあるが、ここでは通常のCプログラムとして終了する。
    */
    return 0;
}

/*
  【期待値と動作確認】
  - ループは10回回り、AXに 1+2+...+10 = 55 が蓄積される
  - sum に 55 が格納され、最終的に "sum = 55" が表示される

  【自作CPUテストとしての使い方（発展）】
  - 命令トレースを取り、各反復で AX と BX がどう変化するか確認すると、
    ALU/フラグ/分岐が正しいかを段階的に検証できる。
*/
