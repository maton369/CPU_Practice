// sum.c
#include <stdio.h>

/*
  【このコードの位置づけ（自作CPU検証の観点）】
  - これは 1〜10 の総和を計算する、非常に基本的なループ処理の例である。
  - 自作CPUにとって重要なのは「加算」そのものよりも、
    ループを成立させるための以下の機能が揃っているかを確認できる点にある。

    ループに必要なCPU機能（典型）：
    1) 変数 i / sum のロード・ストア（メモリアクセス）
    2) 即値（0,1,10）を扱う（即値生成/即値命令）
    3) 比較（i <= 10 の判定）
    4) 条件分岐（ループを続ける/抜ける）
    5) インクリメント（i = i + 1）
    6) ALU加算（sum = sum + i）

  - つまりこのプログラムは「加算 + 分岐 + ループ制御」をまとめてテストできる。
  - 自作CPUを段階的に作る場合、直線的な計算（add.c）よりも一歩進んだ
    “制御（Control Flow）” の動作確認に最適である。
*/

/*
  【注意（C言語としての正しさ）】
  - 通常 main は int を返すのが標準である（int main(void)）。
  - void main(void) は処理系によっては動くが、規格としては推奨されない。
  - 自作CPUでツールチェーン差や警告を減らしたいなら int main(void) が無難。
*/

int i;    // ループ変数 i（グローバル。多くの環境で静的領域に配置される）
int sum;  // 総和 sum（グローバル。静的領域に配置されやすい）

/*
  【自作CPU的に重要：グローバル変数の意味】
  - i と sum がグローバルであることで、一般にメモリ上の固定アドレスに置かれる。
  - その結果、ループ1回ごとに
      load(i), compare, branch, load(sum), add, store(sum), addi(i), store(i)
    のように、メモリアクセスが頻繁に発生しやすい。
  - これは「メモリ系が壊れているとすぐ壊れる」ので、検証素材として良い。
*/

void main(void) {

  /*
    sum = 0;
    - これは総和の初期化（クリア）である。
    - CPU観点では「即値0を生成して sum に書き込む（store）」動作になる。
    - ISAに即値ロードがない場合でも、0は専用レジスタやxorで作るなど、
      実装上の工夫が必要になることがある。
  */
  sum = 0;

  /*
    for (i = 1; i <= 10; i++) { ... }
    このfor文は概念的に以下の3つで構成される。

    (1) 初期化：i = 1
    (2) 継続条件：i <= 10
    (3) 更新：i = i + 1

    自作CPU観点での“肝”は (2) の比較 + 条件分岐である。
    ここができて初めてループが作れる。

    典型的なISAの分解イメージ（概念）：
      i = 1
      loop:
        if (i > 10) goto end   // i <= 10 の否定で抜ける形にされがち
        sum = sum + i
        i = i + 1
        goto loop
      end:

    実際の命令列はCPU/コンパイラ/最適化で変わるが、
    「比較命令（cmp / slt等）」「条件分岐命令（beq/bne/blt等）」
    「無条件ジャンプ（j等）」が必要になる点は共通である。
  */
  for (i = 1; i <= 10; i++) {

    /*
      sum = sum + i;
      - ループの本体で、sumに i を足し込む累積加算である。
      - CPU視点では概ね以下の流れになる。

        1) sum をロード（load sum）
        2) i   をロード（load i）
        3) ALUで加算（add）
        4) 結果を sum にストア（store sum）

      ここで「レジスタファイル」「ALU」「メモリI/F」が一通り動く必要がある。

      注意：
      - sum をレジスタに保持してループ中はメモリに書かない最適化もあり得る。
      - 自作CPU検証では、最適化で命令列が変化して観測しづらくなることがあるので、
        コンパイル時に -O0（最適化なし）を使うのが分かりやすい。
    */
    sum = sum + i;
  }

  /*
    printf は通常、OS/ランタイム/標準ライブラリに強く依存する。
    自作CPU初期段階で printf を動かすには以下が必要になりがち：

    - 関数呼び出し（call/ret）
    - スタック
    - ABI（引数渡し規約）
    - 文字列リテラルの配置と参照
    - I/O（システムコール or UART等の実装）

    Bring-up ではまず printf を使わず、
    sum の値（最終的に 55）をメモリやレジスタ観測で確認する方が段階的に安全。
  */
  printf("sum = %d\n", sum);
}

/*
  【期待される最終結果】
  - 1 + 2 + ... + 10 = 55
  - 自作CPUでこれが正しく出ない場合、原因は以下に分かれやすい。

    (A) 分岐が壊れている：無限ループ or 途中で抜ける
    (B) 比較が壊れている：条件判定が逆/符号がズレる/境界(10)でミスる
    (C) iの更新が壊れている：iが増えない/増えすぎる
    (D) メモリアクセスが壊れている：iやsumの読み書きが別アドレスに行く
    (E) ALU加算が壊れている：加算結果がずれる

  【自作CPUテストとしてのおすすめ運用】
  - printf を外して、最後に
      while(1) {}
    で止めてデバッガ/シミュレータで sum を見る
  - もしくはUARTへ1文字ずつ出す最小I/O関数を用意する
*/
