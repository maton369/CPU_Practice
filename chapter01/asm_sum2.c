/*
  asm_sum2.c（MSVC式 __asm { ... } → GNU拡張インラインasm 変換版）

  【何をしているコードか（全体像）】
  - 1〜10 の総和をアセンブリ命令列で計算し、sum に保存して表示する。
  - 元コードは MSVC のインラインアセンブラ（__asm { ... }）だが、
    Ubuntu の gcc/clang ではその構文は使えないため、GNU拡張の
    asm/asm volatile に書き換える。

  【自作CPU観点での重要ポイント】
  - 加算（add）だけでなく、ループを作るための
      比較（cmp）→ フラグ更新 → 条件分岐（jne）→ PC更新
    が含まれている。
  - レジスタ（AX,BX）で計算し、最後にメモリ（sum）へ書き戻すため、
    データパス（ALU/レジスタ/メモリ）と制御（分岐）を同時に検証できる。

  【注意】
  - ここで使う命令（ax/bx/cmp/jne）は x86/x86_64 前提である。
  - printf は OS/ランタイム依存が大きい（自作CPU単体では後回しにするのが定石）。

  【Cとしての注意】
  - void main(void) は規格上推奨されないため、int main(void) に修正している。
*/

#include <stdio.h>

int main(void) {
    /*
      sum は 16bit の変数（short）。
      - x86 の AX レジスタも 16bit なので、AX→sum への保存が自然に一致する。
      - 自作CPUでは「演算幅」と「保存幅」が一致していることが重要である。
    */
    short sum;

    /*
      GNU拡張インラインasm（GCC/Clang）で、元のMSVC版と同等の処理を記述する。

      重要な設計方針：
      - Intel記法に切り替えると、%0（"=m"(sum)）が -2(%rbp) のように AT&T 風展開され、
        Intel記法側で解釈できずアセンブルエラーになりやすい。
      - よって「最初から最後まで AT&T 記法で統一」し、確実にビルドできる形にする。

      asm volatile の意味：
      - volatile を付けることで、コンパイラ最適化によりasmブロックが消されたり
        不適切に並べ替えられたりするのを防ぐ（副作用があると宣言する）。
    */
    asm volatile(
        /*
          xorw %%ax, %%ax
          - AXを0クリアする（AX = AX XOR AX → 0）。
          - 元コードの mov ax, 0 と同等の効果。
          - xor は即値0を埋め込まないので、命令が短くなる等の利点がある。

          自作CPU観点：
          - XOR命令を持つ設計なら、ゼロクリアに利用できる。
          - XORが無い最小ISAでは「即値ロード」等で0を作る必要がある。
        */
        "xorw %%ax, %%ax\n"

        /*
          movw $1, %%bx
          - BX = 1 に初期化する（ループカウンタ）。
          - 元コードの mov bx, 1 と同等。

          AT&T記法のポイント：
          - 即値は $ を付ける（$1）
          - レジスタは % を付ける（%bx）
          - ただしインラインasm内では % がプレースホルダに使われるので、
            レジスタは %%bx のように % を二重に書く。
        */
        "movw $1, %%bx\n"

        /*
          1: はローカル数字ラベル。
          - GASでは数字ラベルを使える。
          - "jne 1b" の "b" は backward（後ろ方向）で、
            直前に定義された "1:" に戻ることを意味する。
        */
        "1:\n"

        /*
          addw %%bx, %%ax
          - AX = AX + BX（累積和）。
          - 元コードの add ax, bx と同等。

          AT&T記法のポイント：
          - オペランド順は src, dst（元のIntel記法と逆）
            つまり addw %bx, %ax は「%ax += %bx」
        */
        "addw %%bx, %%ax\n"

        /*
          incw %%bx
          - BX = BX + 1（カウンタ更新）。
          - 元コードの inc bx と同等。

          自作CPU観点：
          - inc の専用命令を持つか、addi（add immediate）で代替するかは設計判断。
        */
        "incw %%bx\n"

        /*
          cmpw $11, %%bx
          - BX と 11 を比較し、フラグ（ZFなど）を更新する。
          - 元コードの cmp bx, 11 と同等の判定になる。

          x86の cmp は概念的には「BX - 11」を計算して結果を捨て、
          フラグだけを残す命令である。
        */
        "cmpw $11, %%bx\n"

        /*
          jne 1b
          - “Not Equal” ならジャンプ。
          - 直前の cmp の結果で ZF が更新され、
            ZF=0（等しくない）ならループ先頭へ戻る。
          - BX が 11 になったら cmp で等しい → jneしない → ループ終了。

          ループ回数：
          - BXは 1 から始まり、add→inc なので
            add は BX=1..10 の10回実行され、AXには 55 が蓄積される。
        */
        "jne 1b\n"

        /*
          movw %%ax, %0
          - AX の値（55）を出力オペランド %0 に書き込む。
          - %0 は下の "=m"(sum) に対応し、「sum のメモリ位置」を意味する。
          - 元コードの mov sum, ax（AX→sum）と同等。

          ここが「レジスタ→メモリ（store）」であり、
          自作CPUでは store 命令の検証に相当する。
        */
        "movw %%ax, %0\n"

        /*
          オペランド制約（GCC拡張インラインasmの要点）

          : "=m"(sum)
            - 出力（Output operands）
            - "=m" は「メモリに書く」ことを意味する。
              → asm が sum を更新することをコンパイラに伝える

          : （入力なし）
            - 入力オペランドなし（asm内部で完結）

          : "ax", "bx", "cc"
            - clobber（破壊するもの）
            - AX/BX を asm 内で変更する
            - cmp/jne によりフラグ（condition codes）が変更される
            をコンパイラに伝え、安全に周辺コードと共存させる。
        */
        : "=m"(sum)           // 出力：sum（メモリ）へ書く
        :                     // 入力：なし
        : "ax", "bx", "cc"    // 破壊：AX, BX, フラグ
    );

    /*
      printf は標準ライブラリ依存（OS/ランタイム/I/O）。
      自作CPU bring-up ではまず sum=55 が正しくメモリに入ることを
      デバッガやメモリダンプで確認してから I/O を実装するのが定石。

      表示：
      - sum は short だが可変長引数では int に昇格するため、
        "%d" で表示しても通常問題は起きにくい。
    */
    printf("sum = %d\n", sum);

    return 0;
}

/*
  【コンパイル例（Ubuntu / gcc）】
  - 最小：
      gcc asm_sum2.c -o asm_sum2
  - 検証しやすく（最適化なし + デバッグ情報）：
      gcc -O0 -g asm_sum2.c -o asm_sum2

  【期待出力】
      sum = 55
*/
