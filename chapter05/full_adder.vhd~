-- full_adder.vhd（詳細コメント版）
--
-- 【このモジュールの目的（自作CPU観点）】
-- - 1bitの「全加算器（Full Adder）」である。
-- - 入力 A, B に加えて、下位ビットからの桁上がり CI（Carry In）を受け取り、
--     S  : Sum（和の下位1bit）
--     CO : Carry Out（次段へ渡す桁上がり）
--   を出力する。
--
-- - 自作CPUのALUで Nbit 加算（例：16bit/32bit）を実装するとき、
--   ほぼ必ず「全加算器をビット幅分だけ直列接続（リップルキャリー）」する。
--   その意味で full_adder は「多ビット加算器の基本セル」である。
--
-- 【全加算器の論理（1bit加算の定義）】
-- - 3つの1bit入力 A, B, CI を足し算する：
--
--     A + B + CI  =  (2*CO) + S
--
--   つまり、S は下位1bit、CO は繰り上がり（上位へのキャリー）になる。
--
-- - 真理値表（参考）：
--   A B CI | S CO
--   -------+------
--   0 0  0 | 0  0
--   0 0  1 | 1  0
--   0 1  0 | 1  0
--   0 1  1 | 0  1
--   1 0  0 | 1  0
--   1 0  1 | 0  1
--   1 1  0 | 0  1
--   1 1  1 | 1  1
--
-- - 論理式としては次の形がよく知られている：
--     S  = A xor B xor CI
--     CO = (A and B) or (CI and (A xor B))
--
--   ただし本コードでは、これを「半加算器2個 + OR」で構成している。
--
-- 【この実装の構成方針（半加算器2段）】
-- - 半加算器（half_adder）は入力2本（A,B）だけで
--     S = A xor B
--     CO = A and B
--   を出せる。
-- - 全加算器は次の分解ができる：
--   1) (A,B) を半加算器で足す → 中間和 S_TMP と キャリー CO_TMP1
--   2) (S_TMP,CI) を半加算器で足す → 最終和 S と キャリー CO_TMP2
--   3) 最終キャリー CO = CO_TMP1 OR CO_TMP2
--
-- 自作CPU観点：
-- - この構成は「ビットスライス設計」が直観的に理解しやすい。
-- - ただし、キャリーが直列に伝播する（リップルキャリー）ため、
--   ビット幅を増やすほど遅延が増える（周波数が上がりにくい）という性質がある。
--   高速化には Carry Lookahead 等への発展が必要になる。


library IEEE;
use IEEE.std_logic_1164.all;
-- std_logic 型、および and/or/xor などの論理演算子を使うために読み込む。

-- ============================================================
-- entity: 入出力（ポート）の宣言
-- ============================================================
entity full_adder is
    port(
        -- 入力A, B：加算したい1bit
        A  : in  std_logic;
        B  : in  std_logic;

        -- 入力CI：Carry In（下位ビットからの桁上がり）
        -- 多ビット加算器では、bit(i-1) の CO が bit(i) の CI になる。
        CI : in  std_logic;

        -- 出力S：Sum（和の下位1bit）
        S  : out std_logic;

        -- 出力CO：Carry Out（次段へ渡す桁上がり）
        CO : out std_logic
    );
end full_adder;

-- ============================================================
-- architecture: 回路（内部実装）の記述
-- ============================================================
architecture RTL of full_adder is

    -- --------------------------------------------------------
    -- 半加算器コンポーネント宣言
    -- --------------------------------------------------------
    -- この full_adder は half_adder を内部で2回インスタンス化する。
    -- そのために、half_adder の “部品の形（ポート）” を component として宣言している。
    --
    -- 注意：
    -- - 最近のVHDLでは entity work.half_adder(RTL) のように直接参照する書き方も多いが、
    --   教材としては component 宣言 + port map は古典的で分かりやすい。
    component half_adder
        port(
            A  : in  std_logic;
            B  : in  std_logic;
            S  : out std_logic;
            CO : out std_logic
        );
    end component;

    -- --------------------------------------------------------
    -- 内部信号（中間結果）
    -- --------------------------------------------------------
    -- S_TMP   : 1段目（A+B）の“和”（下位bit）
    -- CO_TMP1 : 1段目（A+B）のキャリー
    -- CO_TMP2 : 2段目（S_TMP + CI）のキャリー
    --
    -- full_adder の内部で「どこでキャリーが発生したか」を可視化できるため、
    -- 自作CPUの加算器デバッグにも役立つ。
    signal S_TMP   : std_logic;
    signal CO_TMP1 : std_logic;
    signal CO_TMP2 : std_logic;

begin

    -- ========================================================
    -- 1段目：A と B の半加算
    -- ========================================================
    -- C1 は half_adder のインスタンス名（ラベル）。
    -- 入力 A,B を与え、中間和 S_TMP とキャリー CO_TMP1 を得る。
    --
    --   S_TMP   = A xor B
    --   CO_TMP1 = A and B
    --
    -- 自作CPU観点：
    -- - ここで CO_TMP1 が立つのは A=B=1 のとき（1+1=10）である。
    -- - つまり “AとBだけで桁上がりが出たか” を表す信号になる。
    C1 : half_adder
        port map(
            A  => A,
            B  => B,
            S  => S_TMP,
            CO => CO_TMP1
        );

    -- ========================================================
    -- 2段目：中間和 S_TMP と Carry In CI の半加算
    -- ========================================================
    -- C2 も half_adder のインスタンス。
    -- 1段目の和 S_TMP と、下位から来たキャリー CI を足して、
    -- 最終和 S とキャリー CO_TMP2 を得る。
    --
    --   S       = S_TMP xor CI = (A xor B) xor CI
    --   CO_TMP2 = S_TMP and CI = (A xor B) and CI
    --
    -- 自作CPU観点：
    -- - ここで CO_TMP2 が立つのは「下位からの桁上がり CI が 1 で、
    --   かつ 1段目の和 S_TMP も 1」のとき。
    -- - これは “CIによって新たに桁上がりが発生した” ことを意味する。
    C2 : half_adder
        port map(
            A  => S_TMP,
            B  => CI,
            S  => S,
            CO => CO_TMP2
        );

    -- ========================================================
    -- 最終キャリー CO の合成
    -- ========================================================
    -- CO は「どちらかの段でキャリーが発生したら1」なので OR を取る。
    --
    --   CO = CO_TMP1 or CO_TMP2
    --
    -- 論理式に直すと：
    --   CO = (A and B) or (CI and (A xor B))
    --
    -- 自作CPU観点：
    -- - CO は次のビットの CI へ渡されるため、加算器全体の遅延（キャリー伝播）を決める。
    -- - リップルキャリー加算器では、COがビット幅分だけ連鎖し、クリティカルパスになりやすい。
    CO <= CO_TMP1 or CO_TMP2;

end RTL;
