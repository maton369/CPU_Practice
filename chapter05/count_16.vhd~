-- count_16.vhd（詳細コメント版：count_nbit を 16bit で呼び出す側）
--
-- 【このモジュールの目的（自作CPU観点）】
-- - 汎用カウンタ count_nbit（ジェネリックでビット幅可変）を 16bit 幅でインスタンス化し、
--   「16bit同期カウンタ」を1つの部品として提供する“ラッパ（wrapper）”である。
--
-- - 自作CPU/SoCでは、汎用部品をパラメタ化しておき、
--   必要な場所で特定幅として呼び出す設計がよく行われる。
--   例：
--   - 16bit タイマ
--   - 16bit 分周カウンタ（上位ビットで低速クロック生成）
--   - 16bit デバッグカウンタ（動作確認用）
--
-- - このファイルは「呼び出し側（インスタンス化側）」の典型例であり、
--   CPU設計全体では“階層化（モジュール分割）”の基本作法に対応する。
--
-- 【アルゴリズム（このモジュール自身の動作）】
-- - 本モジュールは“新しいロジック”を実装していない。
-- - 内部で count_nbit を 1個実体化し、ジェネリック N_BIT を 16 に設定して、
--   入出力をそのまま接続しているだけである。
--
--   したがって、実際の状態更新アルゴリズムは count_nbit のものと同一である：
--   - on rising_edge(CLK):
--       if RST == 1: COUNT := 0
--       else        COUNT := COUNT + 1   (16bit幅)
--
-- 【自作CPU観点での意義】
-- - CPU開発では同じ回路を幅違いで大量に使うため、ジェネリック化＋ラッパは有効。
-- - ラッパを作るメリット：
--   - 上位モジュールから見たインタフェースが固定され、配線が読みやすい
--   - “この用途は16bit” という設計意図がファイル名とポート名で明確になる
--   - 将来 count_nbit の中身を改善しても、呼び出し側は変更せずに恩恵を受けられる


library IEEE;
use IEEE.std_logic_1164.all;
-- このモジュール自体は std_logic と std_logic_vector を扱うだけなので std_logic_1164 のみで十分。

-- ============================================================
-- entity: 入出力（ポート）の宣言
-- ============================================================
entity count_16 is
    port(
        -- CLK: クロック入力（count_nbit にそのまま渡す）
        CLK      : in  std_logic;

        -- RST: リセット入力（count_nbit にそのまま渡す）
        -- ※count_nbit 側の仕様により、同期リセットとして動作する想定。
        RST      : in  std_logic;

        -- COUNT_16: 16bitカウント値の出力
        -- 0〜65535 を数え、オーバーフローで 0 に戻る（mod 2^16）。
        -- 自作CPUではタイマ/分周/ハートビートなどの用途に直結する。
        COUNT_16 : out std_logic_vector(15 downto 0)
    );
end count_16;

-- ============================================================
-- architecture: 回路（内部実装）の記述
-- ============================================================
architecture RTL of count_16 is

    -- --------------------------------------------------------
    -- コンポーネント宣言：count_nbit
    -- --------------------------------------------------------
    -- count_nbit は N_BIT を generic で受け取り、任意幅のカウンタを生成できる部品。
    -- ここでは “呼び出し側” として、必要な幅（16）を指定して使う。
    component count_nbit
        generic(
            -- N_BIT: カウンタのビット幅（デフォルト8だが、呼び出し側で上書きする）
            N_BIT : integer := 8
        );
        port(
            CLK     : in  std_logic;
            RST     : in  std_logic;
            COUNT_N : out std_logic_vector(N_BIT - 1 downto 0)
        );
    end component;

begin

    -- ========================================================
    -- count_nbit の実体化（インスタンス化）
    -- ========================================================
    -- C1 はインスタンス名（ラベル）。
    --
    -- generic map(N_BIT => 16)
    --   - count_nbit のパラメータ N_BIT を 16 に設定する。
    --   - これにより内部状態レジスタは 16bit になり、
    --     +1 は 16bit幅で行われ、2^16 でラップする。
    --
    -- port map(...)
    --   - 上位の CLK/RST を count_nbit の CLK/RST に直結する。
    --   - 出力 COUNT_N を このモジュールの出力 COUNT_16 に直結する。
    --
    -- つまり「16bitカウンタを1個置いただけ」の構造になる。
    C1 : count_nbit
        generic map(
            N_BIT => 16
        )
        port map(
            CLK     => CLK,
            RST     => RST,
            COUNT_N => COUNT_16
        );

end RTL;

-- 【自作CPUでの発展・応用】
-- - COUNT_16(15) のような上位ビットをLEDに繋ぐと低速点滅（分周）として使える。
-- - 一定値到達判定を追加すれば、16bitタイマ割り込み源として使える。
-- - CPUの“時間ベース”を作る最小要素として、周辺回路の土台になる。
