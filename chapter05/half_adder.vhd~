-- half_adder.vhd
-- ============================================================
-- 半加算器 (Half Adder)
-- 1ビットの2入力 A, B を足し算して、
--   - 和 (Sum)        : S
--   - 桁上がり (Carry): CO
-- を出力する最も基本的な加算回路である。
--
-- 真理値表（A,B -> S,CO）
--   A B | S CO
--   ----+-----
--   0 0 | 0  0
--   0 1 | 1  0
--   1 0 | 1  0
--   1 1 | 0  1
--
-- 論理式
--   S  = A xor B    （片方だけ1のとき1）
--   CO = A and B    （両方1のとき1）
-- ============================================================

library IEEE;
use IEEE.std_logic_1164.all;  -- std_logic型と論理演算子(xor/and等)を使うための定義

-- ============================================================
-- entity: 外部から見える「入出力インタフェース」を定義する部分
-- ============================================================
entity half_adder is
	port
	(
		-- A, B: 1ビット入力（std_logicは'0','1'以外に'X','Z'等も表せる）
		--       ただし本回路の意味は基本的に '0'/'1' を想定する
		A	: in std_logic;
		B	: in std_logic;

		-- S : 1ビット和（Sum）
		-- CO: 1ビット桁上がり（Carry Out）
		S	: out std_logic;
		CO	: out std_logic
	);
end half_adder;

-- ============================================================
-- architecture: entityの「中身の回路」を記述する部分
-- RTL (Register Transfer Level) という名前を付けているが、
-- ここではレジスタ(クロック)は使っておらず、純粋な組合せ回路である。
-- ============================================================
architecture RTL of half_adder is
begin
	-- ----------------------------------------------------------
	-- S <= A xor B;
	-- xor は「排他的論理和」：
	--   AとBが異なるときだけ1になる。
	-- したがって、1ビットの足し算における「和」の部分に一致する。
	--
	-- VHDLの <= は「信号代入」であり、
	-- ここでは組合せ回路として A/B の変化に追従して S が更新される。
	-- ----------------------------------------------------------
	S <= A xor B;

	-- ----------------------------------------------------------
	-- CO <= A and B;
	-- and は「論理積」：
	--   AとBが両方1のときだけ1になる。
	-- これは 1 + 1 のときにだけ発生する「桁上がり」に一致する。
	--
	-- これもクロックを使わない組合せ回路なので、
	-- A/B の入力変化に対して CO が即座に（論理遅延は別として）追従する。
	-- ----------------------------------------------------------
	CO <= A and B;

	-- 補足：
	-- 半加算器は「Carry入力(CI)」を持たない。
	-- Carry入力を含めて3入力で足し算する場合は全加算器(Full Adder)になる。
end RTL;
