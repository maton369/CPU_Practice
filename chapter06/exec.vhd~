-- exec.vhd（詳細コメント版：Execute段 / ALU・分岐・ロード/ストア制御・PC更新）
--
-- 【このモジュールの目的（CPU設計観点）】
-- - CPUの Execute 段として、Decode段で切り出された OP_CODE / OP_DATA と、
--   レジスタオペランド REG_A / REG_B、およびメモリ読み出し値 RAM_OUT を入力に取り、
--   命令の意味に従った演算・分岐・メモリアクセス制御を行う。
-- - このCPUの“命令実行アルゴリズム”の中心は exec に集約されており、
--   具体的には以下を同時に扱う。
--
--   1) ALU演算（ADD/SUB/AND/OR/SHIFT など）
--   2) 即値合成（LDL/LDH：上位/下位バイトの差し替え）
--   3) 比較とフラグ保持（CMP → CMP_FLAG）
--   4) 分岐（JE/JMP）によるPC更新
--   5) Load/Store（LD/ST）に伴うレジスタ書き戻し/メモリ書き込み制御
--
-- - つまり「データパス（REG/ALU/RAM）」と「制御（PC/分岐/WriteEnable）」の両方を
--   命令ごとに切り替える“CPUの心臓部”である。
--
-- 【段階実行（FT→DC→EX→WB）との対応】
-- - exec は CLK_EX（Execute段クロック）の立ち上がりで動作し、
--   “この命令で次にPCをどうするか” と “書き戻し/書き込みをどうするか” を確定させる。
-- - 出力の役割は以下。
--
--   P_COUNT : 次にFetch段が参照する命令番地（PC）を出す
--   REG_IN  : レジスタ書き戻し値（WriteBack段の reg_wb へ渡すデータ）
--   RAM_IN  : メモリ書き込みデータ（WriteBack段の ram_wb へ渡す storeデータ）
--   REG_WEN : レジスタ書き戻し有効（Write Enable）
--   RAM_WEN : メモリ書き込み有効（Write Enable）
--
-- - 注意：この設計では exec 自身が “レジスタファイルやRAMの実体” を更新しない。
--   exec はあくまで「次段に対する制御信号と書き込みデータを作る」段であり、
--   実際の更新は reg_wb / ram_wb が CLK_WB で行う。
--   これにより段分割の役割が明確になる。
--
-- 【内部状態：PC と CMP_FLAG】
-- - PC（プログラムカウンタ）は exec 内で保持される“状態”であり、
--   命令ごとに PC+1 / 分岐先 へ更新される。
-- - CMP_FLAG は CMP 命令の結果（REG_A==REG_B）を保持する1bit状態で、
--   JE（Jump Equal）命令が参照する。
-- - 自作CPU観点では、これは「フラグレジスタ（最小版）」の実装であり、
--   将来的に Z/N/C/V などを増やす拡張の入口になる。
--
-- 【リセット挙動（RESET_N）】
-- - RESET_N='0' のとき PC=0, CMP_FLAG=0 に初期化する。
-- - CPU bring-up では “必ず決まった番地から実行が始まる” ことが重要なので、
--   PC初期化は最優先の基本仕様である。


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;

-- ============================================================
-- entity: Execute段の外部インタフェース
-- ============================================================
entity exec is
    port
    (
        -- Execute段クロック：命令の実行（結果・制御の確定）を行うタイミング
        CLK_EX    : in  std_logic;

        -- アクティブLowリセット（RESET_N=0でリセット）
        RESET_N   : in  std_logic;

        -- 命令種別（OP_CODE）: decode段が PROM_OUT(14:11) から抽出
        OP_CODE   : in  std_logic_vector(3 downto 0);

        -- オペランドA/B（reg_dcが選択して渡すレジスタ値）
        REG_A     : in  std_logic_vector(15 downto 0);
        REG_B     : in  std_logic_vector(15 downto 0);

        -- 即値/アドレス（decode段が PROM_OUT(7:0) から抽出）
        OP_DATA   : in  std_logic_vector(7 downto 0);

        -- メモリ読み出し値（ram_dcが選択して渡す値）
        RAM_OUT   : in  std_logic_vector(15 downto 0);

        -- 次にFetchが参照するPC（プログラムカウンタ）
        P_COUNT   : out std_logic_vector(7 downto 0);

        -- レジスタ書き戻し値（WriteBack段へ）
        REG_IN    : out std_logic_vector(15 downto 0);

        -- RAM書き込み値（WriteBack段へ：storeデータ）
        RAM_IN    : out std_logic_vector(15 downto 0);

        -- レジスタ書き込み有効
        REG_WEN   : out std_logic;

        -- RAM書き込み有効
        RAM_WEN   : out std_logic
    );
end exec;

-- ============================================================
-- architecture RTL: 命令に応じて演算・分岐・制御信号を生成
-- ============================================================
architecture RTL of exec is

    -- --------------------------------------------------------
    -- PC: プログラムカウンタ（CPUの内部状態）
    -- --------------------------------------------------------
    -- ここで保持され、命令ごとに更新される。
    signal PC       : std_logic_vector(7 downto 0) := "00000000";

    -- --------------------------------------------------------
    -- CMP_FLAG: 比較結果フラグ（最小版フラグレジスタ）
    -- --------------------------------------------------------
    -- CMP命令が設定し、JE命令が参照する。
    signal CMP_FLAG : std_logic := '0';

begin

    -- ========================================================
    -- Execute段メイン：命令実行
    -- ========================================================
    process(CLK_EX)
    begin
        if (CLK_EX'event and CLK_EX = '1') then

            -- ------------------------------------------------
            -- リセット処理（アクティブLow）
            -- ------------------------------------------------
            if (RESET_N = '0') then
                PC       <= "00000000";  -- 実行開始番地へ戻す
                CMP_FLAG <= '0';         -- 比較フラグも既知値に

            else
                -- ------------------------------------------------
                -- 命令デコード（OP_CODE）に応じた実行
                -- ------------------------------------------------
                case OP_CODE is

                    -- ====================================================
                    -- 0000: MOV（レジスタ間コピー）
                    --   REG_IN = REG_B を生成し、REG_WEN=1で書き戻しさせる
                    --   PCは次命令へ（PC+1）
                    -- ====================================================
                    when "0000" =>
                        REG_IN  <= REG_B;  -- 書き戻しデータ
                        REG_WEN <= '1';    -- レジスタ更新あり
                        RAM_WEN <= '0';    -- メモリ更新なし
                        PC      <= PC + 1;

                    -- ====================================================
                    -- 0001: ADD（加算）
                    --   REG_IN = REG_A + REG_B（ALU加算）
                    --   PC+1
                    -- ====================================================
                    when "0001" =>
                        REG_IN  <= REG_A + REG_B;
                        REG_WEN <= '1';
                        RAM_WEN <= '0';
                        PC      <= PC + 1;

                    -- ====================================================
                    -- 0010: SUB（減算）
                    -- ====================================================
                    when "0010" =>
                        REG_IN  <= REG_A - REG_B;
                        REG_WEN <= '1';
                        RAM_WEN <= '0';
                        PC      <= PC + 1;

                    -- ====================================================
                    -- 0011: AND（論理積）
                    -- ====================================================
                    when "0011" =>
                        REG_IN  <= REG_A and REG_B;
                        REG_WEN <= '1';
                        RAM_WEN <= '0';
                        PC      <= PC + 1;

                    -- ====================================================
                    -- 0100: OR（論理和）
                    -- ====================================================
                    when "0100" =>
                        REG_IN  <= REG_A or REG_B;
                        REG_WEN <= '1';
                        RAM_WEN <= '0';
                        PC      <= PC + 1;

                    -- ====================================================
                    -- 0101: SL（Shift Left Logical：論理左シフト1）
                    --   REG_Aを1bit左へ、LSBに0を入れる
                    --   REG_A(14:0) & '0' は (REG_A << 1) に相当
                    -- ====================================================
                    when "0101" =>
                        REG_IN  <= REG_A(14 downto 0) & '0';
                        REG_WEN <= '1';
                        RAM_WEN <= '0';
                        PC      <= PC + 1;

                    -- ====================================================
                    -- 0110: SR（Shift Right Logical：論理右シフト1）
                    --   MSBに0を入れる
                    -- ====================================================
                    when "0110" =>
                        REG_IN  <= '0' & REG_A(15 downto 1);
                        REG_WEN <= '1';
                        RAM_WEN <= '0';
                        PC      <= PC + 1;

                    -- ====================================================
                    -- 0111: SRA（Shift Right Arithmetic：算術右シフト1）
                    --   MSB（符号ビット相当）を保持して右シフトする
                    --   REG_A(15) & REG_A(15:1)
                    -- ====================================================
                    when "0111" =>
                        REG_IN  <= REG_A(15) & REG_A(15 downto 1);
                        REG_WEN <= '1';
                        RAM_WEN <= '0';
                        PC      <= PC + 1;

                    -- ====================================================
                    -- 1000: LDL（Load Immediate Low）
                    --   下位8bitをOP_DATAで置き換える（上位8bitはREG_Aから保持）
                    --   REG_IN = REG_A[15:8] & OP_DATA
                    -- ====================================================
                    when "1000" =>
                        REG_IN  <= REG_A(15 downto 8) & OP_DATA;
                        REG_WEN <= '1';
                        RAM_WEN <= '0';
                        PC      <= PC + 1;

                    -- ====================================================
                    -- 1001: LDH（Load Immediate High）
                    --   上位8bitをOP_DATAで置き換える（下位8bitはREG_Aから保持）
                    --   REG_IN = OP_DATA & REG_A[7:0]
                    -- ====================================================
                    when "1001" =>
                        REG_IN  <= OP_DATA & REG_A(7 downto 0);
                        REG_WEN <= '1';
                        RAM_WEN <= '0';
                        PC      <= PC + 1;

                    -- ====================================================
                    -- 1010: CMP（比較）
                    --   REG_A == REG_B なら CMP_FLAG=1、それ以外は0
                    --   レジスタやRAMは更新しない（WEN=0）
                    --   PC+1
                    -- ====================================================
                    when "1010" =>
                        if (REG_A = REG_B) then
                            CMP_FLAG <= '1';
                        else
                            CMP_FLAG <= '0';
                        end if;

                        REG_WEN <= '0';
                        RAM_WEN <= '0';
                        PC      <= PC + 1;

                    -- ====================================================
                    -- 1011: JE（Jump if Equal）
                    --   CMP_FLAG==1 なら PC = OP_DATA（分岐先へ）
                    --   そうでなければ PC+1
                    --   データ更新なし
                    -- ====================================================
                    when "1011" =>
                        if (CMP_FLAG = '1') then
                            PC <= OP_DATA;   -- 分岐（絶対番地）
                        else
                            PC <= PC + 1;    -- 不成立なら次命令
                        end if;

                        REG_WEN <= '0';
                        RAM_WEN <= '0';

                    -- ====================================================
                    -- 1100: JMP（無条件ジャンプ）
                    --   PC = OP_DATA
                    -- ====================================================
                    when "1100" =>
                        REG_WEN <= '0';
                        RAM_WEN <= '0';
                        PC      <= OP_DATA;

                    -- ====================================================
                    -- 1101: LD（ロード）
                    --   RAM_OUT（Decode段で読んだメモリ/IO値）をREGに書き戻す
                    --   PC+1
                    -- ====================================================
                    when "1101" =>
                        REG_IN  <= RAM_OUT;
                        REG_WEN <= '1';
                        RAM_WEN <= '0';
                        PC      <= PC + 1;

                    -- ====================================================
                    -- 1110: ST（ストア）
                    --   REG_A を RAM_IN に出し、RAM_WEN=1で書き込みを要求する
                    --   書き込み先アドレスは別経路（ram_dcのRAM_AD_OUT→ram_wb）で伝搬している想定
                    --   PC+1
                    -- ====================================================
                    when "1110" =>
                        RAM_IN  <= REG_A;  -- 書き込みデータ
                        REG_WEN <= '0';
                        RAM_WEN <= '1';    -- メモリ更新あり
                        PC      <= PC + 1;

                    -- ====================================================
                    -- 1111: HLT（停止）
                    --   何も更新しない。PCも更新しないため、以後同じ命令番地に留まる挙動になる。
                    --   （Fetchが同じ番地を読み続ける＝“停止状態”とみなす）
                    -- ====================================================
                    when "1111" =>
                        REG_WEN <= '0';
                        RAM_WEN <= '0';

                    -- ====================================================
                    -- 想定外：何もしない（更新なし）
                    -- ====================================================
                    when others =>
                        null;

                end case;
            end if;
        end if;
    end process;

    -- ========================================================
    -- PCを外へ出す：Fetch段が参照する次命令番地
    -- ========================================================
    P_COUNT <= PC;

end RTL;

-- 【CPU設計としての補足（検証ポイント）】
-- - PC更新規則：通常命令はPC+1、JE/JMPは絶対番地OP_DATAへ。これがFetchと一致しているか。
-- - CMP_FLAGの寿命：CMPの次にJEが来る前提の“単純フラグ”であり、割込み/例外等は未考慮。
-- - LD/STのアドレス：データはRAM_OUT/RAM_INだが、アドレスは別線でram_wbへ届く設計。
--   トップ配線で「どの段のアドレスを使うか」が一致していないと store が壊れる。
-- - HLTの挙動：PCを止めることで“停止”を表現している。明示的なHALT状態信号を追加するとより明確になる。
