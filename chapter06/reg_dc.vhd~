-- reg_dc.vhd（詳細コメント版：Decode段のレジスタ読み出しポート / オペランド選択）
--
-- 【このモジュールの目的（CPU設計観点）】
-- - CPUの Decode 段において、命令が指定するレジスタ番号（N_REG_IN）を使い、
--   レジスタファイル（REG_0〜REG_7）の中から 1本を選んで `REG_OUT` に出力する。
-- - さらに、そのとき選択したレジスタ番号を `N_REG_OUT` として次段へ伝搬する。
--   これは「どのレジスタを参照していたか」という情報を段を跨いで保持するためのもの。
--
-- 【このCPUにおける位置づけ（段階実行アルゴリズムの中で）】
-- - cpu15.vhd では reg_dc を2個インスタンス化している（A側/B側）。
--   例：
--     - A側：命令ビットから N_REG_IN = PROM_OUT(10:8) を渡し、REG_A を生成
--     - B側：命令ビットから N_REG_IN = PROM_OUT(7:5)  を渡し、REG_B を生成
-- - つまりこの reg_dc は “レジスタファイル読み出しポート” の役割を担う。
--   自作CPU観点では、これはデータパスの中心である「レジスタファイルの read port」を
--   モジュール化したもの、と捉えると分かりやすい。
--
-- 【動作タイミング（なぜ CLK_DC でラッチするのか）】
-- - `CLK_DC`（Decode段クロック）立ち上がりでレジスタ値を取り込み、REG_OUT を更新する。
-- - 段階実行（FT→DC→EX→WB）では、各段の境界で値を固定（レジスタ化）して
--   次段が安定値を読むようにするのが重要である。
-- - したがって reg_dc は「デコード段の後ろにある段間レジスタ（パイプラインレジスタ）」
--   の一部も兼ねている。
--
-- 【レジスタ選択のアルゴリズム】
-- 1) 入力 N_REG_IN（3bit）を decode する
-- 2) 対応する REG_x を REG_OUT へ出す
-- 3) 同時に N_REG_OUT <= N_REG_IN として、選択番号をそのまま次段へ持ち越す
--
-- 【N_REG_OUT を出す意味（CPU設計で重要）】
-- - “どのレジスタを読んだか” の情報は、実行段や書き戻し段で必要になることが多い。
-- - 本CPUのトップ配線では、最終的な書き戻し宛先は N_REG_A 側を使う設計になっていた。
--   その場合、段を跨いで「この命令で扱うレジスタ番号」を保持するのは必須になる。
--
-- 【注意：この実装は「同期待ちの多重化器（同期MUX）」である】
-- - 純粋なレジスタファイル（多ポートRAM）とは異なり、
--   ここでは REG_0〜REG_7 の値が外から全て入力で入ってきており、
--   それを case 文で選んでいる。
-- - つまりハードウェアとしては「8:1 MUX + 出力レジスタ」に近い。
-- - 教材CPUとしては分かりやすい構成だが、
--   将来レジスタ数を増やすと入力ポートが爆発するので、
--   本格化するなら “配列化（reg array）+ indexed read” の形にするのが自然である。


library IEEE;
use IEEE.std_logic_1164.all;

-- ============================================================
-- entity: Decode段のレジスタ読み出し（1ポート分）
-- ============================================================
entity reg_dc is
    port
    (
        -- Decode段クロック：ここで選択結果をラッチして次段へ渡す
        CLK_DC     : in  std_logic;

        -- 命令から来るレジスタ番号（3bit → 0〜7）
        N_REG_IN   : in  std_logic_vector(2 downto 0);

        -- レジスタファイルの各レジスタ値（外部から入力として与えられる）
        REG_0      : in  std_logic_vector(15 downto 0);
        REG_1      : in  std_logic_vector(15 downto 0);
        REG_2      : in  std_logic_vector(15 downto 0);
        REG_3      : in  std_logic_vector(15 downto 0);
        REG_4      : in  std_logic_vector(15 downto 0);
        REG_5      : in  std_logic_vector(15 downto 0);
        REG_6      : in  std_logic_vector(15 downto 0);
        REG_7      : in  std_logic_vector(15 downto 0);

        -- 次段へ渡すレジスタ番号（段間で番号も保持する）
        N_REG_OUT  : out std_logic_vector(2 downto 0);

        -- 選択されたレジスタの値（オペランド）
        REG_OUT    : out std_logic_vector(15 downto 0)
    );
end reg_dc;

-- ============================================================
-- architecture RTL: case分岐で8本から選択し、段クロックでラッチ
-- ============================================================
architecture RTL of reg_dc is

begin

    process(CLK_DC)
    begin
        -- Decode段クロックの立ち上がりで選択結果を更新
        if (CLK_DC'event and CLK_DC = '1') then

            -- ------------------------------------------------
            -- 8本のレジスタから N_REG_IN に一致するものを選ぶ
            -- ------------------------------------------------
            case N_REG_IN is
                when "000"  => REG_OUT <= REG_0; -- レジスタ0
                when "001"  => REG_OUT <= REG_1; -- レジスタ1
                when "010"  => REG_OUT <= REG_2; -- レジスタ2
                when "011"  => REG_OUT <= REG_3; -- レジスタ3
                when "100"  => REG_OUT <= REG_4; -- レジスタ4
                when "101"  => REG_OUT <= REG_5; -- レジスタ5
                when "110"  => REG_OUT <= REG_6; -- レジスタ6
                when "111"  => REG_OUT <= REG_7; -- レジスタ7
                when others => null;             -- 保険（基本的には到達しない）
            end case;

            -- ------------------------------------------------
            -- 選択した番号を次段へ持ち越す
            -- ------------------------------------------------
            -- 「どのレジスタを対象にした命令か」を段を跨いで保持するために重要。
            N_REG_OUT <= N_REG_IN;

        end if;
    end process;

end RTL;

-- 【CPU設計としての次の論点】
-- - reg_dcが同期MUXとして動く前提（CLK_DCでラッチ）を全段で統一できているか。
-- - 書き戻し宛先がAフィールド固定なら、N_REG_OUTのどちら（A側/B側）を使うのかが仕様になる。
-- - レジスタ数を増やすなら配列化し、for/with-select等でスケーラブルにするのが良い。
