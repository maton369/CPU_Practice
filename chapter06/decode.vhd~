-- decode.vhd（詳細コメント版：命令デコード段 / 命令フィールド抽出）
--
-- 【このモジュールの目的（CPU設計観点）】
-- - Fetch段がPROMから取り出した命令語 `PROM_OUT(14 downto 0)` を受け取り、
--   その中から “実行に必要なフィールド” を切り出して出力する。
-- - 本CPUでは最低限、
--   - OP_CODE : 命令の種類（ADD, SUB, JMP など）を表すオペコード
--   - OP_DATA : 即値（LDL/LDHの値、JMP/JEの飛び先、ロード/ストアのアドレスなど）
--   を decode 段で生成し、次段（exec）へ渡す。
--
-- 【デコード段の設計上の位置づけ】
-- - decode は ISA（命令セット仕様）を“ビット配置として固定する”段である。
-- - つまり「命令語のどのビットが何を意味するか」をここで決めており、
--   この切り出しが CPU 全体の契約（命令フォーマット）になる。
-- - 自作CPUでの典型的なバグは、
--   - ビット範囲の取り違え（14..11 を 13..10 と勘違いする等）
--   - 下位ビットの意味（即値/アドレス/レジスタ番号）がブロック間で不一致
--   なので、decode は最重要の整合ポイントである。
--
-- 【命令フォーマット（このモジュールが前提としている仕様）】
-- - 命令語は 15bit（bit14がMSB）。
-- - OP_CODE は上位4bit：PROM_OUT(14 downto 11)
--   → 16種類（0〜15）の命令を表現できる。
-- - OP_DATA は下位8bit：PROM_OUT(7 downto 0)
--   → 8bit即値/アドレスとして扱える。
--
-- - ここで注目すべきなのは、
--   PROM_OUT(10 downto 8) や PROM_OUT(7 downto 5) のような
--   “レジスタ番号フィールド” は、このdecodeでは出力していない点である。
--   それらはトップ階層（cpu15.vhd）で直接切り出して reg_dc / ram_dc に渡される設計になっている。
--   つまり命令語は概念的に
--
--     [14:11] OP_CODE
--     [10: 8] REG_A 番号
--     [ 7: 5] REG_B 番号（または用途によって別フィールド）
--     [ 7: 0] OP_DATA（即値/アドレス）
--
--   のように “用途が重なる領域” を持っており、命令種別によってビットの意味が変わる
--   （典型的な“可変解釈フォーマット”）になっている。
--
-- 【動作タイミング（段階実行との整合）】
-- - このCPUは clk_gen により段別クロックで進む。
-- - decode は `CLK_DC` の立ち上がりで命令をラッチし、
--   OP_CODE/OP_DATA を更新する。
-- - これにより、次の exec 段（CLK_EX）から見ると OP_CODE/OP_DATA が安定した入力になる。
-- - 重要なのは「Fetchの出力PROM_OUTが十分安定してからDecodeがサンプルする」位相関係であり、
--   それは clk_gen の設計に依存する（トップ統合で常に確認すべき点）。
--
-- 【なぜ process(CLK_DC) でラッチするのか】
-- - 組合せ回路で単に `OP_CODE <= PROM_OUT(14 downto 11);` としても動作はするが、
--   段階実行では “段境界で値を固定する（レジスタ化する）” ことで
--   次段での読みやすさ・タイミングの安全性が上がる。
-- - したがって、このdecodeは「段間レジスタ（パイプラインレジスタ的役割）」も兼ねている。


library IEEE;
use IEEE.std_logic_1164.all;

-- ============================================================
-- entity: Decode段の外部インタフェース
-- ============================================================
entity decode is
    port
    (
        -- Decode段用ステージクロック
        -- この立ち上がりで命令ビット列を取り込み、OP_CODE/OP_DATAを更新する。
        CLK_DC    : in  std_logic;

        -- Fetch段が出力した命令語（15bit）
        PROM_OUT  : in  std_logic_vector(14 downto 0);

        -- 命令の種類（上位4bit）
        OP_CODE   : out std_logic_vector(3 downto 0);

        -- 命令に付随する8bitデータ（即値/アドレス）
        OP_DATA   : out std_logic_vector(7 downto 0)
    );
end decode;

-- ============================================================
-- architecture RTL: 命令ビット列からフィールドを切り出してラッチ
-- ============================================================
architecture RTL of decode is

begin

    -- ========================================================
    -- Decode段：段クロックで命令フィールドを取り込む
    -- ========================================================
    process(CLK_DC)
    begin
        -- 立ち上がりエッジで更新（同期回路の基本形）
        if (CLK_DC'event and CLK_DC = '1') then

            -- ------------------------------------------------
            -- OP_CODE（命令種別）：bit[14:11]
            -- ------------------------------------------------
            -- 例：
            --  - ADD/SUB/AND/OR/SHIFT/LDL/LDH/CMP/JE/JMP/LD/ST/HLT などの種別をここで識別する。
            OP_CODE <= PROM_OUT(14 downto 11);

            -- ------------------------------------------------
            -- OP_DATA（即値/アドレス）：bit[7:0]
            -- ------------------------------------------------
            -- 例：
            --  - LDL/LDH の即値（8bit）
            --  - JE/JMP の分岐先アドレス（8bit）
            --  - LD/ST のメモリアドレス（8bit）
            -- 命令種別によって意味が変わる“多目的フィールド”として扱う。
            OP_DATA <= PROM_OUT(7 downto 0);

        end if;
    end process;

end RTL;

-- 【CPU設計としての確認ポイント】
-- - 命令仕様で OP_CODE を [14:11] とすることが全ブロックで一致しているか。
-- - OP_DATA を [7:0] とすることが exec / ram_dc / fetch のプログラム内容と一致しているか。
-- - PROM_OUT(10:8),(7:5) のレジスタ番号はトップで直接配線しているため、
--   命令種別ごとのフィールド解釈が破綻していないか（特に [7:0] と [7:5] の重なり）。
